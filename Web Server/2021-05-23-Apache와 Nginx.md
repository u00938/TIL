[Reference](https://www.youtube.com/watch?v=ZhfpYgl8BtQ)

#### Apache와 Nginx의 차이?

연결 및 트래픽을 처리하고 다양한 트래픽 조건에 대응하는 방법이 다르다.

<br>

## 연결 처리 비교

#### Apache

클라이언트의 요청을 처리하는 다양한 MPMs(multi-processing modules) 제공 (mpm_prefork, mpm_worker, mpm_event)

MPMs는 서로 다른 서버 요구(needs) / 부하(loads)에 적합한 세 가지 타입의 요청 처리 알고리즘이다. 다양한 연결 및 요청 처리 알고리즘을 선택할 수 있는 유연한 아키텍처를 제공한다. 이러한 유연성을 위해 자원이 소모된다.

#### Nginx

비동기-논블로킹 이벤트 기반 알고리즘으로 설계되어 있다.

각각 수천 개의 연결을 처리 할 수있는 작업자 프로세스(worker process)를 생성한다.

이러한 연결 처리 모델을 통해 제한된 리소스로 매우 빠르고 광범위하게 확장 할 수 있다. (부하가 높더라도 메모리 및 CPU 사용량은 상대적으로 일정하게 유지됨)

<br>

## 정적 컨텐츠와 동적 컨텐츠

#### Apache

기존의 파일 기반 방법을 사용하여 정적 콘텐츠를 처리한다.

동적으로 로드 가능한 모듈을 통해 외부 구성 요소에 의존하지 않고도 웹 서버 자체 내에서 동적 콘텐츠를 처리 할 수 ​​있다.

#### Nginx

동적 콘텐츠를 자체적으로 처리 할 수 ​​없다. 

콘텐츠(ex. PHP script)를 외부 프로세서로 전달하여 실행하고, 렌더링 된 콘텐츠가 다시 전송 될 때까지 기다린다.

<br>

## 분산(distributed) / 중앙집중(centralized) 구성

#### Apache

.htaccess 파일(분산 설정 파일)의 지시문을 해석하여 디렉토리별로 추가 구성을 허용할 수 있다.(per-directory configuration)

기본 구성 파일을 편집 할 수있는 권한이 없는 사용자가 웹 사이트의 특정 부분을 제어하도록 허용 할 수 있다.

## Nginx

디렉토리 단위의 구성에 대한 메커니즘을 제공하지 않는다.

.htaccess 파일을 검색하고 해석할 필요가 없기 때문에 성능 향상에 도움이 된다.

<br>

## 파일 / URI 기반 해석

#### Apache

요청을 파일 시스템의 물리적 리소스, 또는 URL 위치로 해석 할 수 있다.

#### Nginx 

웹 서버이자 프록시 서버로 만들어졌다.

필요한 경우 주로 URI를 파일 시스템으로 변환하여 작동한다.

파일 시스템 디렉토리에 대한 구성을 지정하는 메커니즘을 제공하지 않고 대신 URI 자체를 전달한다.

파일 시스템 위치 대신 URI와 비슷하게 요청을 전달하면 Nginx가 웹 서버와 프록시 서버 모두에서 더 쉽게 작동 할 수 있다.

Nginx는 다양한 요청 패턴에 응답하는 방법을 간단히 배치하여 구성된다.

Nginx는 요청을 처리 할 준비가 될 때까지 파일 시스템을 확인하지 않기 때문에 어떤 형태의 .htaccess 파일도 실행하지 않는다.

<br>

## 모듈

#### Apache

모듈 시스템을 사용하면 모듈을 동적으로 로드하거나 언로드 할 수 있다.

Apache 코어는 항상 존재하는 반면 모듈은 기능을 추가 또는 제거하고 메인 서버에 연결을 켜거나 끌 수 있다.

#### Nginx

모듈을 선택하고 핵심(core) 소프트웨어로 컴파일해야 한다. (동적으로 로드 할 수 없음)

사용하려는 기능만 포함하여 서버에서 원하는 것을 지시 할 수 있다.

<br>

## Apache & Nginx

Nginx를 Apache 앞에 역방향 프록시로 두면 Nginx가 클라이언트의 모든 요청을 처리 할 수 ​​있다. Nginx의 빠른 처리 속도와 많은 수의 연결을 동시에 처리 할 수 있는 능력을 이용한다. 

정적 콘텐츠의 경우 Nginx를 통해  파일이 클라이언트에 신속하게 직접 제공된다.

동적 콘텐츠의 경우 Nginx는 Apache에 대한 요청을 프록시를 사용하여(대신) 결과를 처리 후 렌더링 된 페이지를 반환하고, 해당 콘텐츠를 클라이언트로 다시 전달할 수 있다.

이 모델을 사용하면 매우 기능적인 웹 서버를 가질 수 있고 많은 사용자에게 매우 빠르게 서비스를 제공 할 수 있다.







